/**
 * Composant de vérification KYC pour le processus d'inscription
 * @module components/registration/steps/KycVerification
 */

import React, { useState, useEffect, useRef } from 'react';
import { motion } from 'framer-motion';
import { Upload, Trash2, Eye, CheckCircle, AlertTriangle, Loader, ArrowLeft } from 'lucide-react';
import { registrationService } from '../../../services/registration/registrationService';
import { KycVerificationProps } from './StepProps';
import { RegistrationSession } from '../../../types/registration';

/**
 * Types de documents requis pour la vérification KYC
 */
type DocumentType = 'idCard' | 'addressProof' | 'businessRegistration' | 'openingAuthorization';

/**
 * Structure d'un document KYC
 */
interface KycDocument {
  type: DocumentType;
  file: File | null;
  preview: string | null;
  uploaded: boolean;
  uploading: boolean;
  error: string | null;
  required: boolean;
  documentId?: string;
}

// Utilisation de l'interface KycVerificationProps définie dans StepProps.ts

/**
 * Composant de vérification KYC guidée (5-10 minutes)
 */
const KycVerification: React.FC<KycVerificationProps> = ({
  sessionData,
  updateSessionData,
  goToNextStep, 
  goToPreviousStep,
  saveSession
}) => {
  // État des documents
  const [documents, setDocuments] = useState<Record<DocumentType, KycDocument>>(() => ({
    idCard: {
      type: 'idCard',
      file: null,
      preview: null,
      uploaded: false,
      uploading: false,
      error: null,
      required: true,
    },
    addressProof: {
      type: 'addressProof',
      file: null,
      preview: null,
      uploaded: false,
      uploading: false,
      error: null,
      required: true,
    },
    businessRegistration: {
      type: 'businessRegistration',
      file: null,
      preview: null,
      uploaded: false,
      uploading: false,
      error: null,
      required: true,
    },
    openingAuthorization: {
      type: 'openingAuthorization',
      file: null,
      preview: null,
      uploaded: false,
      uploading: false,
      error: null,
      required: true,
    },
  }));
  
  // État global du composant
  // Note: isSubmitting est utilisé dans submitDocuments pour éviter les soumissions multiples
  const [allDocumentsUploaded, setAllDocumentsUploaded] = useState<boolean>(false);
  const [currentPreview, setCurrentPreview] = useState<string | null>(null);
  const [submissionStatus, setSubmissionStatus] = useState<'idle' | 'submitting' | 'success' | 'error'>('idle');
  
  const fileInputRefs = useRef<Record<DocumentType, HTMLInputElement | null>>({
    idCard: null,
    addressProof: null,
    businessRegistration: null,
    openingAuthorization: null,
  });
  
  // Charger les documents existants depuis la session
  useEffect(() => {
    if (sessionData?.kyc?.documents) {
      const updatedDocuments = { ...documents };
      let allUploaded = true;
      
      Object.entries(sessionData.kyc.documents).forEach(([type, docInfo]) => {
        if (type in updatedDocuments && docInfo.documentId) {
          updatedDocuments[type as DocumentType] = {
            ...updatedDocuments[type as DocumentType],
            uploaded: true,
            documentId: docInfo.documentId,
            preview: docInfo.previewUrl || null,
          };
        } else {
          allUploaded = false;
        }
      });
      
      setDocuments(updatedDocuments);
      setAllDocumentsUploaded(allUploaded);
    }
  }, [sessionData, documents]);
  
  // Vérifier si tous les documents requis sont téléchargés
  useEffect(() => {
    const requiredDocuments = Object.values(documents).filter(doc => doc.required);
    const allUploaded = requiredDocuments.every(doc => doc.uploaded);
    setAllDocumentsUploaded(allUploaded);
  }, [documents]);
  
  // Obtenir le libellé d'un type de document
  const getDocumentLabel = (type: DocumentType): string => {
    switch (type) {
      case 'idCard': return "Pièce d'identité";
      case 'addressProof': return "Justificatif d'adresse";
      case 'businessRegistration': return "Registre de commerce";
      case 'openingAuthorization': return "Autorisation d'ouverture";
      default: return "Document";
    }
  };
  
  // Gérer le changement de fichier
  const handleFileChange = async (type: DocumentType, event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0] || null;
    if (!file) return;
    
    // Vérifier le type de fichier (PDF, JPG, PNG)
    const validTypes = ['application/pdf', 'image/jpeg', 'image/png', 'image/jpg'];
    if (!validTypes.includes(file.type)) {
      setDocuments(prev => ({
        ...prev,
        [type]: {
          ...prev[type],
          error: 'Format de fichier non valide. Utilisez PDF, JPG ou PNG.',
          file: null
        }
      }));
      return;
    }
    
    // Vérifier la taille du fichier (max 5 MB)
    const maxSize = 5 * 1024 * 1024; // 5 MB
    if (file.size > maxSize) {
      setDocuments(prev => ({
        ...prev,
        [type]: {
          ...prev[type],
          error: 'Fichier trop volumineux. Maximum 5 MB.',
          file: null
        }
      }));
      return;
    }
    
    // Créer une URL de prévisualisation
    const preview = URL.createObjectURL(file);
    
    // Mettre à jour l'état du document
    setDocuments(prev => ({
      ...prev,
      [type]: {
        ...prev[type],
        file,
        preview,
        error: null,
        uploaded: false,
        uploading: false
      }
    }));
    
    // Télécharger automatiquement le fichier
    await uploadDocument(type, file);
  };
  
  // Télécharger un document
  const uploadDocument = async (type: DocumentType, file: File) => {
    if (!sessionData?.id) return;
    
    setDocuments(prev => ({
      ...prev,
      [type]: {
        ...prev[type],
        uploading: true,
        error: null
      }
    }));
    
    try {
      // Créer un FormData pour l'upload
      const formData = new FormData();
      formData.append('document', file);
      formData.append('type', type);
      
      // Appeler le service pour télécharger le document
      const result = await registrationService.uploadKycDocument(sessionData.id, type, formData);
      
      if (result && result.documentId) {
        // Mettre à jour l'état du document
        setDocuments(prev => ({
          ...prev,
          [type]: {
            ...prev[type],
            uploaded: true,
            uploading: false,
            documentId: result.documentId,
            error: null
          }
        }));
        
        // Mettre à jour les données de session
        const kycData = sessionData?.kyc || {};
        const kycDocuments = kycData.documents || {};
        
        updateSessionData({
          kyc: {
            ...kycData,
            documents: {
              ...kycDocuments,
              [type]: {
                documentId: result.documentId,
                status: 'pending',
                uploadedAt: new Date().toISOString(),
                previewUrl: documents[type].preview
              }
            }
          }
        } as Partial<RegistrationSession>);
        
        // Sauvegarder la session
        await saveSession();
      } else {
        throw new Error('Erreur lors du téléchargement du document');
      }
    } catch (error) {
      console.error(`Erreur lors du téléchargement du document ${type}:`, error);
      
      setDocuments(prev => ({
        ...prev,
        [type]: {
          ...prev[type],
          uploading: false,
          error: 'Erreur lors du téléchargement. Veuillez réessayer.'
        }
      }));
    }
  };
  
  // Supprimer un document
  const removeDocument = async (type: DocumentType) => {
    if (!sessionData?.id || !documents[type].documentId) return;
    
    try {
      // Appeler le service pour supprimer le document
      await registrationService.deleteKycDocument(sessionData.id, documents[type].documentId!);
      
      // Libérer l'URL de prévisualisation
      if (documents[type].preview) {
        URL.revokeObjectURL(documents[type].preview);
      }
      
      // Mettre à jour l'état du document
      setDocuments(prev => ({
        ...prev,
        [type]: {
          ...prev[type],
          file: null,
          preview: null,
          uploaded: false,
          uploading: false,
          error: null,
          documentId: undefined
        }
      }));
      
      // Mettre à jour les données de session
      const kycData = sessionData?.kyc || {};
      const updatedKycDocuments = { ...(kycData.documents || {}) };
      delete updatedKycDocuments[type];
      
      updateSessionData({
        kyc: {
          ...kycData,
          documents: updatedKycDocuments
        }
      } as Partial<RegistrationSession>);
      
      // Sauvegarder la session
      await saveSession();
    } catch (error) {
      console.error(`Erreur lors de la suppression du document ${type}:`, error);
    }
  };
  
  // Afficher la prévisualisation d'un document
  const showPreview = (previewUrl: string | null) => {
    if (previewUrl) {
      setCurrentPreview(previewUrl);
    }
  };
  
  // Fermer la prévisualisation
  const closePreview = () => {
    setCurrentPreview(null);
  };
  
  // Soumettre tous les documents pour vérification
  const submitDocuments = async () => {
    if (!sessionData?.id) return;
    
    setSubmissionStatus('submitting');
    
    try {
      // Préparer les documents à soumettre
      const kycDocuments = Object.values(documents)
        .filter(doc => doc.uploaded && doc.file)
        .map(doc => ({
          document_type: doc.type,
          document_number: `${doc.type}-${Date.now()}`,
          file: doc.file as File
        }));
      
      // Soumettre les documents au service
      await registrationService.submitKycDocuments(sessionData.id, kycDocuments);
      
      // Mettre à jour la session
      updateSessionData({
        kyc: {
          ...sessionData.kyc,
          status: 'submitted',
          submittedAt: new Date().toISOString()
        }
      });
      
      await saveSession();
      
      setSubmissionStatus('success');
      
      // Passer à l'étape suivante après un délai
      setTimeout(() => {
        goToNextStep();
      }, 2000);
    } catch (error) {
      console.error('Erreur lors de la soumission des documents KYC:', error);
      setSubmissionStatus('error');
    }
  };
  
  // Nettoyer les URL de prévisualisation à la démonter du composant
  useEffect(() => {
    return () => {
      // Libérer toutes les URL de prévisualisation
      Object.values(documents).forEach(doc => {
        if (doc.preview) {
          URL.revokeObjectURL(doc.preview);
        }
      });
    };
  }, [documents]);

  return (
    <motion.div 
      className="kyc-verification-container"
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      exit={{ opacity: 0 }}
      transition={{ duration: 0.5 }}
    >
      <style>
        {`
          .preview-image {
            max-width: 100%;
            max-height: 80vh;
            object-fit: contain;
          }
        `}
      </style>
      <h2 className="step-title">Vérification KYC</h2>
      <p className="step-description">
        Pour finaliser votre inscription, veuillez télécharger les documents requis pour la vérification KYC (Know Your Customer).
      </p>
      
      {submissionStatus === 'success' ? (
        <div className="submission-success">
          <CheckCircle size={48} className="success-icon" />
          <h3>Documents soumis avec succès!</h3>
          <p>Nous avons bien reçu vos documents. Ils seront vérifiés dans les plus brefs délais.</p>
        </div>
      ) : (
        <div className="kyc-form">
          {/* Document: Pièce d'identité */}
          <div className="document-card">
            <h3>{getDocumentLabel('idCard')}</h3>
            <p className="document-description">Carte d'identité nationale, passeport ou permis de conduire.</p>
            
            {documents.idCard.uploaded ? (
              <div className="document-preview-container">
                <div className="document-actions">
                  <button 
                    type="button" 
                    className="btn btn-sm btn-outline-primary"
                    onClick={() => showPreview(documents.idCard.preview)}
                  >
                    <Eye size={16} className="mr-1" /> Voir
                  </button>
                  <button 
                    type="button" 
                    className="btn btn-sm btn-outline-danger"
                    onClick={() => removeDocument('idCard')}
                  >
                    <Trash2 size={16} className="mr-1" /> Supprimer
                  </button>
                </div>
                <div className="document-status">
                  <CheckCircle size={16} className="text-success mr-1" /> Document téléchargé
                </div>
            ) : (
              <div className="document-upload-container">
                <input
                  type="file"
                  id="openingAuthorization-upload"
                  className="document-input"
                  onChange={(e) => handleFileChange('openingAuthorization', e)}
                  accept=".pdf,.jpg,.jpeg,.png"
                  ref={el => fileInputRefs.current.openingAuthorization = el}
                  disabled={documents.openingAuthorization.uploading}
                  title="Télécharger l'autorisation d'ouverture"
                  placeholder="Télécharger l'autorisation d'ouverture"
                  aria-label="Autorisation d'ouverture"
                />
                <button
                  type="button"
                  className="btn btn-primary upload-btn"
                  onClick={() => fileInputRefs.current.openingAuthorization?.click()}
                  disabled={documents.openingAuthorization.uploading}
                >
                  {documents.openingAuthorization.uploading ? (
                    <>
                      <Loader size={16} className="mr-1 animate-spin" /> Téléchargement...
                    </>
                  ) : (
                    <>
                      <Upload size={16} className="mr-1" /> Télécharger
                    </>
                  )}
                </button>
                {documents.openingAuthorization.error && (
                  <div className="document-error">
                    <AlertTriangle size={16} className="mr-1" /> {documents.openingAuthorization.error}
                  </div>
                )}
              </div>
            )}
          </div>
        </div>
      )}
      
      {/* Modal de prévisualisation */}
      {currentPreview && (
        <div className="preview-modal">
          <div className="preview-content">
            <button type="button" className="close-btn" onClick={closePreview}>
              &times;
            </button>
            {currentPreview.endsWith('.pdf') ? (
              <iframe 
                src={currentPreview} 
                title="Document Preview" 
                width="100%" 
                height="500px"
              />
            ) : (
              <img 
                src={currentPreview} 
                alt="Document Preview" 
                className="preview-image" 
              />
            )}
          </div>
        </div>
      )}
      
      {/* Boutons de navigation */}
      <div className="step-navigation">
        <button 
          type="button" 
          className="btn btn-outline-secondary"
          onClick={goToPreviousStep}
          disabled={submissionStatus === 'submitting' || submissionStatus === 'success'}
        >
          <ArrowLeft size={16} className="mr-1" /> Retour
        </button>
        
        <button 
          type="button" 
          className="btn btn-primary"
          onClick={submitDocuments}
          disabled={!allDocumentsUploaded || submissionStatus === 'submitting' || submissionStatus === 'success'}
        >
          {submissionStatus === 'submitting' ? (
            <>
              <Loader size={16} className="mr-1 animate-spin" /> Soumission en cours...
            </>
          ) : (
            'Soumettre pour vérification'
          )}
        </button>
      </div>
      
      {/* Informations supplémentaires */}
      <div className="kyc-info">
        <h4>Informations importantes</h4>
        <ul>
          <li>Tous les documents doivent être lisibles et non expirés.</li>
          <li>Les formats acceptés sont PDF, JPG et PNG (max 5 MB par fichier).</li>
          <li>La vérification peut prendre jusqu'à 24-48 heures ouvrables.</li>
          <li>Vous recevrez une notification par email une fois la vérification terminée.</li>
        </ul>
      </div>
    </motion.div>
  );
};

export default KycVerification;
